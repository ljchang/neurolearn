<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API Reference &#8212; nltools 0.4.4 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery-rendered-html.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js "></script>

<!-- Google Analytics -->
<script>
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "https://www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-138438649-1", "auto");
  ga("send", "pageview");
</script>
<!-- End Google Analytics -->

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          nltools</a>
        <span class="navbar-text navbar-version pull-left"><b>0.4.4</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="install.html">Installation</a></li>
                <li><a href="#">API</a></li>
                <li><a href="auto_examples/index.html">Tutorials</a></li>
                <li><a href="http://www.github.com/ljchang/nltools">Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">TOC <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">API Reference</a><ul>
<li><a class="reference internal" href="#nltools-data-data-types"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.data</span></code>: Data Types</a></li>
<li><a class="reference internal" href="#nltools-analysis-analysis-tools"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.analysis</span></code>: Analysis Tools</a></li>
<li><a class="reference internal" href="#module-nltools.stats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.stats</span></code>: Stats Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-statistics-tools">NeuroLearn Statistics Tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.datasets</span></code>: Dataset Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-datasets">NeuroLearn datasets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.cross_validation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.cross_validation</span></code>: Cross-Validation Tools</a><ul>
<li><a class="reference internal" href="#cross-validation-data-classes">Cross-Validation Data Classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.mask"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.mask</span></code>: Mask Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-mask-classes">NeuroLearn Mask Classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.file_reader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.file_reader</span></code>: File Reading</a><ul>
<li><a class="reference internal" href="#neurolearn-file-reading-tools">NeuroLearn File Reading Tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.util</span></code>: Utilities</a><ul>
<li><a class="reference internal" href="#neurolearn-utilities">NeuroLearn Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.plotting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.plotting</span></code>: Plotting Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-plotting-tools">NeuroLearn Plotting Tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-nltools.simulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.simulator</span></code>: Simulator Tools</a><ul>
<li><a class="reference internal" href="#neurolearn-simulator-tools">NeuroLearn Simulator Tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#index">Index</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="api-reference">
<span id="api-ref"></span><h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>This reference provides detailed documentation for all modules, classes, and
methods in the current release of Neurolearn.</p>
<div class="section" id="nltools-data-data-types">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.data</span></code>: Data Types<a class="headerlink" href="#nltools-data-data-types" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="nltools.data.Brain_Data">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.data.</span></code><code class="sig-name descname"><span class="pre">Brain_Data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Brain_Data is a class to represent neuroimaging data in python as a vector
rather than a 3-dimensional matrix.This makes it easier to perform data
manipulation and analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – nibabel data instance or list of files</p></li>
<li><p><strong>Y</strong> – Pandas DataFrame of training labels</p></li>
<li><p><strong>X</strong> – Pandas DataFrame Design Matrix for running univariate models</p></li>
<li><p><strong>mask</strong> – binary nifiti file to mask brain data</p></li>
<li><p><strong>output_file</strong> – Name to write out to nifti file</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltools.data.Brain_Data.aggregate">
<code class="sig-name descname"><span class="pre">aggregate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.aggregate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Brain_Data instance that aggregages func over mask</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.align">
<code class="sig-name descname"><span class="pre">align</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'procrustes'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.align"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align Brain_Data instance to target object using functional alignment</p>
<p>Alignment type can be hyperalignment or Shared Response Model. When
using hyperalignment, <cite>target</cite> image can be another subject or an
already estimated common model. When using SRM, <cite>target</cite> must be a previously
estimated common model stored as a numpy array. Transformed data can be back
projected to original data using Tranformation matrix.</p>
<p>See nltools.stats.align for aligning multiple Brain_Data instances</p>
<p class="rubric">Examples</p>
<dl class="simple">
<dt>Hyperalign using procrustes transform:</dt><dd><p>out = data.align(target, method=’procrustes’)</p>
</dd>
<dt>Align using shared response model:</dt><dd><p>out = data.align(target, method=’probabilistic_srm’, n_features=None)</p>
</dd>
<dt>Project aligned data into original data:</dt><dd><p>original_data = np.dot(out[‘transformed’].data,out[‘transformation_matrix’].T)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> – (Brain_Data) object to align to.</p></li>
<li><p><strong>method</strong> – (str) alignment method to use
[‘probabilistic_srm’,’deterministic_srm’,’procrustes’]</p></li>
<li><p><strong>axis</strong> – (int) axis to align on</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) a dictionary containing transformed object,</dt><dd><p>transformation matrix, and the shared response matrix</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.append">
<code class="sig-name descname"><span class="pre">append</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to Brain_Data instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (Brain_Data) Brain_Data instance to append</p></li>
<li><p><strong>kwargs</strong> – optional inputs to Design_Matrix append</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Brain_Data) new appended Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.apply_mask">
<code class="sig-name descname"><span class="pre">apply_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample_mask_to_brain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.apply_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask Brain_Data instance</p>
<p>Note target data will be resampled into the same space as the mask. If you would like the mask
resampled into the Brain_Data space, then set resample_mask_to_brain=True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – (Brain_Data or nifti object) mask to apply to Brain_Data object.</p></li>
<li><p><strong>resample_mask_to_brain</strong> – (bool) Will resample mask to brain space before applying mask (default=False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Brain_Data) masked Brain_Data object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>masked</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.astype">
<code class="sig-name descname"><span class="pre">astype</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.astype"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast Brain_Data.data as type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> – datatype to convert</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Brain_Data instance with new datatype</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.bootstrap">
<code class="sig-name descname"><span class="pre">bootstrap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap a Brain_Data method.</p>
<blockquote>
<div><p>Example Useage:
b = dat.bootstrap(‘mean’, n_samples=5000)
b = dat.bootstrap(‘predict’, n_samples=5000, algorithm=’ridge’)
b = dat.bootstrap(‘predict’, n_samples=5000, save_weights=True)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> – (str) method to apply to data for each bootstrap</p></li>
<li><p><strong>n_samples</strong> – (int) number of samples to bootstrap with replacement</p></li>
<li><p><strong>save_weights</strong> – (bool) Save each bootstrap iteration
(useful for aggregating many bootstraps on a cluster)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.Returns:</p></li>
</ul>
</dd>
</dl>
<p>output: summarized studentized bootstrap output</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of a Brain_Data instance.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.decompose">
<code class="sig-name descname"><span class="pre">decompose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'voxels'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.decompose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose Brain_Data object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – (str) Algorithm to perform decomposition
types=[‘pca’,’ica’,’nnmf’,’fa’,’dictionary’,’kernelpca’]</p></li>
<li><p><strong>axis</strong> – dimension to decompose [‘voxels’,’images’]</p></li>
<li><p><strong>n_components</strong> – (int) number of components. If None then retain
as many as possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dictionary of decomposition parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.detrend">
<code class="sig-name descname"><span class="pre">detrend</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.detrend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove linear trend from each voxel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>type</strong> – (‘linear’,’constant’, optional) type of detrending</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Brain_Data) detrended Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.distance">
<code class="sig-name descname"><span class="pre">distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distance between images within a Brain_Data() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>metric</strong> – (str) type of distance metric (can use any scikit learn or
sciypy metric)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Adjacency) Outputs a 2D distance matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dist</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.dtype">
<code class="sig-name descname"><span class="pre">dtype</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.dtype"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data type of Brain_Data.data.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.empty">
<code class="sig-name descname"><span class="pre">empty</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.empty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalize Brain_Data.data as empty</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.extract_roi">
<code class="sig-name descname"><span class="pre">extract_roi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.extract_roi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.extract_roi" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract activity from mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – (nifti) nibabel mask can be binary or numbered for
different rois</p></li>
<li><p><strong>metric</strong> – type of extraction method [‘mean’, ‘median’, ‘pca’], (default=mean)
NOTE: Only mean currently works!</p></li>
<li><p><strong>n_components</strong> – if metric=’pca’, number of components to return (takes any input into sklearn.Decomposition.PCA)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>mean within each ROI across images</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.filter">
<code class="sig-name descname"><span class="pre">filter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_pass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply 5th order butterworth filter to data. Wraps nilearn
functionality. Does not default to detrending and standardizing like
nilearn implementation, but this can be overridden using kwargs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling_freq</strong> – sampling freq in hertz (i.e. 1 / TR)</p></li>
<li><p><strong>high_pass</strong> – high pass cutoff frequency</p></li>
<li><p><strong>low_pass</strong> – low pass cutoff frequency</p></li>
<li><p><strong>kwargs</strong> – other keyword arguments to nilearn.signal.clean</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Filtered Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.find_spikes">
<code class="sig-name descname"><span class="pre">find_spikes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">global_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.find_spikes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.find_spikes" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to identify spikes from Time Series Data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>global_spike_cutoff</strong> – (int,None) cutoff to identify spikes in global signal
in standard deviations, None indicates do not calculate.</p></li>
<li><p><strong>diff_spike_cutoff</strong> – (int,None) cutoff to identify spikes in average frame difference
in standard deviations, None indicates do not calculate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>pandas dataframe with spikes as indicator variables</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.groupby">
<code class="sig-name descname"><span class="pre">groupby</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.groupby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Create groupby instance</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.icc">
<code class="sig-name descname"><span class="pre">icc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">icc_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'icc2'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.icc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.icc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Calculate intraclass correlation coefficient for data within</dt><dd><p>Brain_Data class</p>
</dd>
</dl>
<p>ICC Formulas are based on:
Shrout, P. E., &amp; Fleiss, J. L. (1979). Intraclass correlations: uses in
assessing rater reliability. Psychological bulletin, 86(2), 420.</p>
<p>icc1:  x_ij = mu + beta_j + w_ij
icc2/3:  x_ij = mu + alpha_i + beta_j + (ab)_ij + epsilon_ij</p>
<p>Code modifed from nipype algorithms.icc
<a class="reference external" href="https://github.com/nipy/nipype/blob/master/nipype/algorithms/icc.py">https://github.com/nipy/nipype/blob/master/nipype/algorithms/icc.py</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>icc_type</strong> – type of icc to calculate (icc: voxel random effect,
icc2: voxel and column random effect, icc3: voxel and
column fixed effect)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(np.array) intraclass correlation coefficient</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ICC</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.iplot">
<code class="sig-name descname"><span class="pre">iplot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anatomical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.iplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.iplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an interactive brain viewer for the current brain data instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> – (float/str) two-sided threshold to initialize the
visualization, maybe be a percentile string; default 0</p></li>
<li><p><strong>surface</strong> – (bool) whether to create a surface-based plot; default False</p></li>
<li><p><strong>anatomical</strong> – nifti image or filename to overlay</p></li>
<li><p><strong>kwargs</strong> – optional arguments to nilearn.view_img or
nilearn.view_img_on_surf</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>interactive brain viewer widget</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.isempty">
<code class="sig-name descname"><span class="pre">isempty</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.isempty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if Brain_Data.data is empty</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.mean">
<code class="sig-name descname"><span class="pre">mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Get mean of each voxel or image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) across images=0 (default), within images=1</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float/np.array/Brain_Data)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.median">
<code class="sig-name descname"><span class="pre">median</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.median"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Get median of each voxel or image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) across images=0 (default), within images=1</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float/np.array/Brain_Data)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.multivariate_similarity">
<code class="sig-name descname"><span class="pre">multivariate_similarity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.multivariate_similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.multivariate_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict spatial distribution of Brain_Data() instance from linear
combination of other Brain_Data() instances or Nibabel images</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> – Brain_Data instance of data to be applied</p></li>
<li><p><strong>images</strong> – Brain_Data instance of weight map</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary of regression statistics in Brain_Data</dt><dd><p>instances {‘beta’,’t’,’p’,’df’,’residual’}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anatomical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'axial'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_bg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">draw_cross</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quick plot of self.data.  Will plot each image separately</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>limit</strong> – (int) max number of images to return</p></li>
<li><p><strong>anatomical</strong> – (nifti, str) nifti image or file name to overlay</p></li>
<li><p><strong>view</strong> – (str) ‘axial’ for limit number of axial slices;
‘glass’ for ortho-view glass brain; ‘mni’ for
multi-slice view mni brain; ‘full’ for both glass and
mni views</p></li>
<li><p><strong>threshold_upper</strong> – (str/float) threshold if view is ‘glass’,
‘mni’, or ‘full’</p></li>
<li><p><strong>threshold_lower</strong> – (str/float)threshold if view is ‘glass’,
‘mni’, or ‘full’</p></li>
<li><p><strong>save</strong> – (str/bool): optional string file name or path for saving; only applies if view is ‘mni’, ‘glass’, or ‘full’.
Filenames will appended with the orientation they belong to</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.predict">
<code class="sig-name descname"><span class="pre">predict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Run prediction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – Algorithm to use for prediction.  Must be one of ‘svm’,
‘svr’, ‘linear’, ‘logistic’, ‘lasso’, ‘ridge’,
‘ridgeClassifier’,’pcr’, or ‘lassopcr’</p></li>
<li><p><strong>cv_dict</strong> – Type of cross_validation to use. A dictionary of
{‘type’: ‘kfolds’, ‘n_folds’: n},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘stratified’: Y},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘subject_id’: holdout}, or
{‘type’: ‘loso’, ‘subject_id’: holdout}
where ‘n’ = number of folds, and ‘holdout’ = vector of
subject ids that corresponds to self.Y</p></li>
<li><p><strong>plot</strong> – Boolean indicating whether or not to create plots.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dictionary of prediction parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.predict_multi">
<code class="sig-name descname"><span class="pre">predict_multi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'searchlight'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rois</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.predict_multi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.predict_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform multi-region prediction. This can be a searchlight analysis or multi-roi analysis if provided a Brain_Data instance with labeled non-overlapping rois.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> (<em>string</em>) – algorithm to use for prediction Must be one of ‘svm’,
‘svr’, ‘linear’, ‘logistic’, ‘lasso’, ‘ridge’,
‘ridgeClassifier’,’pcr’, or ‘lassopcr’</p></li>
<li><p><strong>cv_dict</strong> – Type of cross_validation to use. Default is 3-fold. A dictionary of
{‘type’: ‘kfolds’, ‘n_folds’: n},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘stratified’: Y},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘subject_id’: holdout}, or
{‘type’: ‘loso’, ‘subject_id’: holdout}
where ‘n’ = number of folds, and ‘holdout’ = vector of
subject ids that corresponds to self.Y</p></li>
<li><p><strong>method</strong> (<em>string</em>) – one of ‘searchlight’ or ‘roi’</p></li>
<li><p><strong>rois</strong> (<em>string/nltools.Brain_Data</em>) – nifti file path or Brain_data instance containing non-overlapping regions-of-interest labeled by integers</p></li>
<li><p><strong>process_mask</strong> (<em>nib.Nifti1Image/nltools.Brain_Data</em>) – mask to constrain where to perform analyses; only applied if method = ‘searchlight’</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – radius of searchlight in mm; default 2mm</p></li>
<li><p><strong>scoring</strong> (<em>function</em>) – callable scoring function; see sklearn documentation; defaults to estimator’s default scoring function</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of CPUs to use to do permutation; default 1 because this can be very memory intensive</p></li>
<li><p><strong>verbose</strong> (<em>int</em>) – whether parallelization progress should be printed; default 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>image of results</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.r_to_z">
<code class="sig-name descname"><span class="pre">r_to_z</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.r_to_z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.r_to_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Fisher’s r to z transformation to each element of the data
object.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.randomise">
<code class="sig-name descname"><span class="pre">randomise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.randomise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.randomise" title="Permalink to this definition">¶</a></dt>
<dd><p>Run mass-univariate regression at each voxel with inference performed
via permutation testing ala randomise in FSL. Operates just like
.regress(), but intended to be used for second-level analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_permute</strong> (<em>int</em>) – number of permutations</p></li>
<li><p><strong>threshold_dict</strong> – (dict) a dictionary of threshold parameters
{‘unc’:.001} or {‘fdr’:.05}</p></li>
<li><p><strong>return_mask</strong> – (bool) optionally return the thresholding mask</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary of maps for betas, tstats, and pvalues</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.regions">
<code class="sig-name descname"><span class="pre">regions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_region_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1350</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extract_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'local_regions'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.regions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract brain connected regions into separate regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_region_size</strong> (<em>int</em>) – Minimum volume in mm3 for a region to be
kept.</p></li>
<li><p><strong>extract_type</strong> (<em>str</em>) – Type of extraction method
[‘connected_components’, ‘local_regions’].
If ‘connected_components’, each component/region
in the image is extracted automatically by
labelling each region based upon the presence of
unique features in their respective regions.
If ‘local_regions’, each component/region is
extracted based on their maximum peak value to
define a seed marker and then using random
walker segementation algorithm on these
markers for region separation.</p></li>
<li><p><strong>smoothing_fwhm</strong> (<em>scalar</em>) – Smooth an image to extract more sparser
regions. Only works for extract_type
‘local_regions’.</p></li>
<li><p><strong>is_mask</strong> (<em>bool</em>) – Whether the Brain_Data instance should be treated
as a boolean mask and if so, calls
connected_label_regions instead.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Brain_Data instance with extracted ROIs as data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.regress">
<code class="sig-name descname"><span class="pre">regress</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.regress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a mass-univariate regression across voxels. Three types of regressions can be run:
1) Standard OLS (default)
2) Robust OLS (heteroscedasticty and/or auto-correlation robust errors), i.e. OLS with “sandwich estimators”
3) ARMA (auto-regressive and moving-average lags = 1 by default; experimental)</p>
<p>For more information see the help for nltools.stats.regress</p>
<p>ARMA notes: This experimental mode is similar to AFNI’s 3dREMLFit but without spatial smoothing of voxel auto-correlation estimates. It can be <strong>very computationally intensive</strong> so parallelization is used by default to try to speed things up. Speed is limited because a unique ARMA model is fit to <em>each voxel</em> (like AFNI/FSL), but unlike SPM, which assumes the same AR parameters (~0.2) at each voxel. While coefficient results are typically very similar to OLS, std-errors and so t-stats, dfs and and p-vals can differ greatly depending on how much auto-correlation is explaining the response in a voxel
relative to other regressors in the design matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<em>str</em>) – kind of model to fit; must be one of ‘ols’ (default), ‘robust’, or ‘arma’</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – keyword arguments to nltools.stats.regress</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary of regression statistics in Brain_Data instances</dt><dd><p>{‘beta’,’t’,’p’,’df’,’residual’}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.scale">
<code class="sig-name descname"><span class="pre">scale</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.scale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.scale" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Scale all values such that they are on the range [0, scale_val],</dt><dd><p>via grand-mean scaling. This is NOT global-scaling/intensity
normalization. This is useful for ensuring that data is on a
common scale (e.g. good for multiple runs, participants, etc)
and if the default value of 100 is used, can be interpreted as
something akin to (but not exactly) “percent signal change.”
This is consistent with default behavior in AFNI and SPM.
Change this value to 10000 to make consistent with FSL.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale_val</strong> – (int/float) what value to send the grand-mean to;
default 100</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.shape">
<code class="sig-name descname"><span class="pre">shape</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get images by voxels shape.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.similarity">
<code class="sig-name descname"><span class="pre">similarity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate similarity of Brain_Data() instance with single
Brain_Data or Nibabel image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – (Brain_Data, nifti)  image to evaluate similarity</p></li>
<li><p><strong>method</strong> – (str) Type of similarity
[‘correlation’,’dot_product’,’cosine’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(list) Outputs a vector of pattern expression values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pexp</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.smooth">
<code class="sig-name descname"><span class="pre">smooth</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwhm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.smooth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply spatial smoothing using nilearn smooth_img()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fwhm</strong> – (float) full width half maximum of gaussian spatial filter</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Brain_Data instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.standardize">
<code class="sig-name descname"><span class="pre">standardize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'center'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.standardize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize Brain_Data() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> – 0 for observations 1 for voxels</p></li>
<li><p><strong>method</strong> – [‘center’,’zscore’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Brain_Data Instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.std">
<code class="sig-name descname"><span class="pre">std</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.std"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Get standard deviation of each voxel or image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) across images=0 (default), within images=1</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float/np.array/Brain_Data)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.sum">
<code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum over voxels.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.temporal_resample">
<code class="sig-name descname"><span class="pre">temporal_resample</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hz'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.temporal_resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.temporal_resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample Brain_Data timeseries to a new target frequency or number of samples
using Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) interpolation.
This function can up- or down-sample data.</p>
<p>Note: this function can use quite a bit of RAM.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>sampling_freq:  (float) sampling frequency of data in hertz
target: (float) upsampling target
target_type: (str) type of target can be [samples,seconds,hz]</p>
</dd>
<dt>Returns:</dt><dd><p>upsampled Brain_Data instance</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.threshold">
<code class="sig-name descname"><span class="pre">threshold</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binarize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.threshold" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Threshold Brain_Data instance. Provide upper and lower values or</dt><dd><p>percentages to perform two-sided thresholding. Binarize will return
a mask image respecting thresholds if provided, otherwise respecting
every non-zero value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upper</strong> – (float or str) Upper cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>lower</strong> – (float or str) Lower cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>binarize</strong> (<em>bool</em>) – return binarized image respecting thresholds if
provided, otherwise binarize on every non-zero value;
default False</p></li>
<li><p><strong>coerce_nan</strong> (<em>bool</em>) – coerce nan values to 0s; default True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Thresholded Brain_Data object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.to_nifti">
<code class="sig-name descname"><span class="pre">to_nifti</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.to_nifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Brain_Data Instance into Nifti Object</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.transform_pairwise">
<code class="sig-name descname"><span class="pre">transform_pairwise</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.transform_pairwise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.transform_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract brain connected regions into separate regions.</p>
<p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Brain_Data instance tranformed into pairwise comparisons</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#nltools.data.Brain_Data" title="nltools.data.Brain_Data">Brain_Data</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.ttest">
<code class="sig-name descname"><span class="pre">ttest</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.ttest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate one sample t-test across each voxel (two-sided)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold_dict</strong> – (dict) a dictionary of threshold parameters
{‘unc’:.001} or {‘fdr’:.05}</p></li>
<li><p><strong>return_mask</strong> – (bool) if thresholding is requested, optionall return the mask of voxels that exceed threshold, e.g. for use with another map</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) dictionary of regression statistics in Brain_Data</dt><dd><p>instances {‘t’,’p’}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.upload_neurovault">
<code class="sig-name descname"><span class="pre">upload_neurovault</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">access_token</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_modality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.upload_neurovault"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.upload_neurovault" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Upload Data to Neurovault.  Will add any columns in self.X to image</dt><dd><p>metadata. Index will be used as image name.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>access_token</strong> – (str, Required) Neurovault api access token</p></li>
<li><p><strong>collection_name</strong> – (str, Optional) name of new collection to create</p></li>
<li><p><strong>collection_id</strong> – (int, Optional) neurovault collection_id if adding images
to existing collection</p></li>
<li><p><strong>img_type</strong> – (str, Required) Neurovault map_type</p></li>
<li><p><strong>img_modality</strong> – (str, Required) Neurovault image modality</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame) neurovault collection information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>collection</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.write">
<code class="sig-name descname"><span class="pre">write</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out Brain_Data object to Nifti or HDF5 File.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> – (str) name of nifti file including path</p></li>
<li><p><strong>kwargs</strong> – optional arguments to deepdish.io.save</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Brain_Data.z_to_r">
<code class="sig-name descname"><span class="pre">z_to_r</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Brain_Data.z_to_r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Brain_Data.z_to_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert z score back into r value for each element of data object</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltools.data.Adjacency">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.data.</span></code><code class="sig-name descname"><span class="pre">Adjacency</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjacency is a class to represent Adjacency matrices as a vector rather
than a 2-dimensional matrix. This makes it easier to perform data
manipulation and analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – pandas data instance or list of files</p></li>
<li><p><strong>matrix_type</strong> – (str) type of matrix.  Possible values include:
[‘distance’,’similarity’,’directed’,’distance_flat’,
‘similarity_flat’,’directed_flat’]</p></li>
<li><p><strong>Y</strong> – Pandas DataFrame of training labels</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltools.data.Adjacency.append">
<code class="sig-name descname"><span class="pre">append</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to Adjacency instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – (Adjacency) Adjacency instance to append</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Adjacency) new appended Adjacency instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.bootstrap">
<code class="sig-name descname"><span class="pre">bootstrap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap an Adjacency method.</p>
<blockquote>
<div><p>Example Useage:
b = dat.bootstrap(‘mean’, n_samples=5000)
b = dat.bootstrap(‘predict’, n_samples=5000, algorithm=’ridge’)
b = dat.bootstrap(‘predict’, n_samples=5000, save_weights=True)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> – (str) method to apply to data for each bootstrap</p></li>
<li><p><strong>n_samples</strong> – (int) number of samples to bootstrap with replacement</p></li>
<li><p><strong>save_weights</strong> – (bool) Save each bootstrap iteration
(useful for aggregating many bootstraps on a cluster)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.Returns:</p></li>
</ul>
</dd>
</dl>
<p>output: summarized studentized bootstrap output</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.cluster_summary">
<code class="sig-name descname"><span class="pre">cluster_summary</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">summary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'within'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.cluster_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.cluster_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>This function provides summaries of clusters within Adjacency matrices.</p>
<p>It can compute mean/median of within and between cluster values. Requires a
list of cluster ids indicating the row/column of each cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clusters</strong> – (list) list of cluster labels</p></li>
<li><p><strong>metric</strong> – (str) method to summarize mean or median. If ‘None” then return all r values</p></li>
<li><p><strong>summary</strong> – (str) summarize within cluster or between clusters</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) within cluster means</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of Adjacency object.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.distance">
<code class="sig-name descname"><span class="pre">distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distance between images within an Adjacency() instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>metric</strong> – (str) type of distance metric (can use any scikit learn or
sciypy metric)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Adjacency) Outputs a 2D distance matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dist</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.distance_to_similarity">
<code class="sig-name descname"><span class="pre">distance_to_similarity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.distance_to_similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.distance_to_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert distance matrix to similarity matrix.</p>
<p>Note: currently only implemented for correlation and euclidean.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>metric</strong> – (str) Can only be correlation or euclidean</p></li>
<li><p><strong>beta</strong> – (float) parameter to scale exponential function (default: 1) for euclidean</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Adjacency) Adjacency object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.generate_permutations">
<code class="sig-name descname"><span class="pre">generate_permutations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.generate_permutations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.generate_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate n_perm permutated versions of Adjacency in a lazy fashion. Useful for iterating against.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_perm</strong> (<em>int</em>) – number of permutations</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>np.random.seed</em><em>, </em><em>optional</em>) – random seed for reproducibility. Defaults to None.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">generate_permutations</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">out</span> <span class="o">=</span> <span class="n">neural_distance_mat</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="o">...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p><em>Adjacency</em> – permuted version of self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.isc">
<code class="sig-name descname"><span class="pre">isc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_bootstraps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_self_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_bootstraps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.isc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute intersubject correlation.</p>
<p>This implementation uses the subject-wise bootstrap method from Chen et al., 2016.
Instead of recomputing the pairwise ISC using circle_shift or phase_randomization methods,
this approach uses the computationally more efficient method of bootstrapping the subjects
and computing a new pairwise similarity matrix with randomly selected subjects with replacement.
If the same subject is selected multiple times, we set the perfect correlation to a nan with
(exclude_self_corr=True). As recommended by Chen et al., 2016, we compute the median pairwise ISC
by default. However, if the mean is preferred, we compute the mean correlation after performing
the fisher r-to-z transformation and then convert back to correlations to minimize artificially
inflating the correlation values. We compute the p-values using the percentile method using the same
method in Brainiak.</p>
<p>Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,
&amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:
nonparametric approaches to inter-subject correlation analysis at the group level.
NeuroImage, 142, 248-259.</p>
<p>Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.
Biometrics, 757-762.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bootstraps</strong> – (int) number of bootstraps</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,’kendall’]</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.isempty">
<code class="sig-name descname"><span class="pre">isempty</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.isempty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if Adjacency object is empty</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.mean">
<code class="sig-name descname"><span class="pre">mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mean of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate mean over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1</dt><dd><p>and multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.median">
<code class="sig-name descname"><span class="pre">median</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.median"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate median of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate median over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1</dt><dd><p>and multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Heatmap of Adjacency Matrix</p>
<p>Can pass in any sns.heatmap argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>limit</strong> – (int) number of heatmaps to plot if object contains multiple adjacencies (default: 3)</p></li>
<li><p><strong>axes</strong> – matplotlib axis handle</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.plot_label_distance">
<code class="sig-name descname"><span class="pre">plot_label_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a violin plot indicating within and between label distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>labels</strong> (<em>np.array</em>) – numpy array of labels to plot</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>violin plot handles</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.plot_mds">
<code class="sig-name descname"><span class="pre">plot_mds</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">n_components=2,</span> <span class="pre">metric=True,</span> <span class="pre">labels=None,</span> <span class="pre">labels_color=None,</span> <span class="pre">cmap=&lt;matplotlib.colors.LinearSegmentedColormap</span> <span class="pre">object&gt;,</span> <span class="pre">n_jobs=-1,</span> <span class="pre">view=(30,</span> <span class="pre">20),</span> <span class="pre">figsize=[12,</span> <span class="pre">8],</span> <span class="pre">ax=None,</span> <span class="pre">*args,</span> <span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot_mds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot_mds" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Multidimensional Scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_components</strong> – (int) Number of dimensions to project (can be 2 or 3)</p></li>
<li><p><strong>metric</strong> – (bool) Perform metric or non-metric dimensional scaling; default</p></li>
<li><p><strong>labels</strong> – (list) Can override labels stored in Adjacency Class</p></li>
<li><p><strong>labels_color</strong> – (str) list of colors for labels, if len(1) then make all same color</p></li>
<li><p><strong>n_jobs</strong> – (int) Number of parallel jobs</p></li>
<li><p><strong>view</strong> – (tuple) view for 3-Dimensional plot; default (30,20)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.plot_silhouette">
<code class="sig-name descname"><span class="pre">plot_silhouette</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.plot_silhouette"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.plot_silhouette" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a silhouette plot</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.r_to_z">
<code class="sig-name descname"><span class="pre">r_to_z</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.r_to_z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.r_to_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Fisher’s r to z transformation to each element of the data
object.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.regress">
<code class="sig-name descname"><span class="pre">regress</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.regress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a regression on an adjacency instance.
You can decompose an adjacency instance with another adjacency instance.
You can also decompose each pixel by passing a design_matrix instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – Design matrix can be an Adjacency or Design_Matrix instance</p></li>
<li><p><strong>method</strong> – type of regression (default: ols)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of stats outputs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.shape">
<code class="sig-name descname"><span class="pre">shape</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate shape of data.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.similarity">
<code class="sig-name descname"><span class="pre">similarity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spearman'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate similarity between two Adjacency matrices.
Default is to use spearman correlation and permutation test.
:param data: Adjacency data, or 1-d array same size as self.data
:param perm_type: (str) ‘1d’,’2d’, or None
:param metric: (str) ‘spearman’,’pearson’,’kendall’
:param ignore_diagonal: (bool) only applies to ‘directed’ Adjacency types using perm_type=None or perm_type=’1d’</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.social_relations_model">
<code class="sig-name descname"><span class="pre">social_relations_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">summarize_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.social_relations_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.social_relations_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the social relations model from a matrix for a round-robin design.</p>
<p>X_{ij} = m + lpha_i + eta_j + g_{ij} + epsilon_{ijl}</p>
<p>where X_{ij} is the score for person i rating person j, m is the group mean,
lpha_i  is person i’s actor effect, eta_j is person j’s partner effect, g_{ij}
is the relationship  effect and epsilon_{ijl} is the error in measure l  for actor i and partner j.</p>
<p>This model is primarily concerned with partioning the variance of the various effects.</p>
<p>Code is based on implementation presented in Chapter 8 of Kenny, Kashy, &amp; Cook (2006).
Tests replicate examples  presented in the book. Note, that this method assumes that
actor scores are rows (lower triangle), while partner scores are columnns (upper triangle).
The minimal sample size to estimate these effects is 4.</p>
<dl class="simple">
<dt>Model Assumptions:</dt><dd><ul class="simple">
<li><p>Social interactions are exclusively dyadic</p></li>
<li><p>People are randomly sampled from population</p></li>
<li><p>No order effects</p></li>
<li><p>The effects combine additively and relationships are linear</p></li>
</ul>
</dd>
</dl>
<p>In the future we might update the formulas and standard errors based on
Bond and Lashley, 1996</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> – (adjacency) can be a single matrix or many matrices for each group</p></li>
<li><p><strong>summarize_results</strong> – (bool) will provide a formatted summary of model results</p></li>
<li><p><strong>nan_replace</strong> – (bool) will replace nan values with row and column means</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.Series/pd.DataFrame) All of the effects estimated using SRM</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>estimated effects</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.square_shape">
<code class="sig-name descname"><span class="pre">square_shape</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.square_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.square_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate shape of squareform data.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.squareform">
<code class="sig-name descname"><span class="pre">squareform</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.squareform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.squareform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert adjacency back to squareform</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.stats_label_distance">
<code class="sig-name descname"><span class="pre">stats_label_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.stats_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.stats_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate permutation tests on within and between label distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<em>np.array</em>) – numpy array of labels to plot</p></li>
<li><p><strong>n_permute</strong> (<em>int</em>) – number of permutations to run (default=5000)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>dictionary of within and between group differences</dt><dd><p>and p-values</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.std">
<code class="sig-name descname"><span class="pre">std</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.std"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate standard deviation of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate std over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1 and</dt><dd><p>multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>std</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.sum">
<code class="sig-name descname"><span class="pre">sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sum of Adjacency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> – (int) calculate mean over features (0) or data (1).
For data it will be on upper triangle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>float if single, adjacency if axis=0, np.array if axis=1</dt><dd><p>and multiple</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.threshold">
<code class="sig-name descname"><span class="pre">threshold</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binarize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.threshold" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Threshold Adjacency instance. Provide upper and lower values or</dt><dd><p>percentages to perform two-sided thresholding. Binarize will return
a mask image respecting thresholds if provided, otherwise respecting
every non-zero value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>upper</strong> – (float or str) Upper cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>lower</strong> – (float or str) Lower cutoff for thresholding. If string
will interpret as percentile; can be None for one-sided
thresholding.</p></li>
<li><p><strong>binarize</strong> (<em>bool</em>) – return binarized image respecting thresholds if
provided, otherwise binarize on every non-zero value;
default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>thresholded Adjacency instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltools.data.Adjacency" title="nltools.data.Adjacency">Adjacency</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.to_graph">
<code class="sig-name descname"><span class="pre">to_graph</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.to_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.to_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Adjacency into networkx graph.  only works on
single_matrix for now.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.ttest">
<code class="sig-name descname"><span class="pre">ttest</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.ttest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ttest across samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>permutation</strong> – (bool) Run ttest as permutation. Note this can be very slow.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) contains Adjacency instances of t values (or mean if</dt><dd><p>running permutation) and Adjacency instance of p values.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.write">
<code class="sig-name descname"><span class="pre">write</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'long'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out Adjacency object to csv file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_name</strong> (<em>str</em>) – name of file name to write</p></li>
<li><p><strong>method</strong> (<em>str</em>) – method to write out data [‘long’,’square’]</p></li>
<li><p><strong>kwargs</strong> – optional arguments to deepdish.io.save</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Adjacency.z_to_r">
<code class="sig-name descname"><span class="pre">z_to_r</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/adjacency.html#Adjacency.z_to_r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Adjacency.z_to_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert z score back into r value for each element of data object</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltools.data.Groupby">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.data.</span></code><code class="sig-name descname"><span class="pre">Groupby</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="nltools.data.Groupby.apply">
<code class="sig-name descname"><span class="pre">apply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Brain_Data instance methods to each element of Groupby
object.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Groupby.combine">
<code class="sig-name descname"><span class="pre">combine</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby.combine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine value dictionary back into masks</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Groupby.split">
<code class="sig-name descname"><span class="pre">split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/brain_data.html#Groupby.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Groupby.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split Brain_Data instance into separate masks and store as a
dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltools.data.Design_Matrix">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.data.</span></code><code class="sig-name descname"><span class="pre">Design_Matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Design_Matrix is a class to represent design matrices with special methods for data processing (e.g. convolution, upsampling, downsampling) and also intelligent and flexible and intelligent appending (e.g. auto-matically keep certain columns or polynomial terms separated during concatentation). It plays nicely with Brain_Data and can be used to build an experimental design to pass to Brain_Data’s X attribute. It is essentially an enhanced pandas df, with extra attributes and methods. Methods always return a new design matrix instance (copy). Column names are always string types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling_freq</strong> (<em>float</em>) – sampling rate of each row in hertz; To covert seconds to hertz (e.g. in the case of TRs for neuroimaging) using hertz = 1 / TR</p></li>
<li><p><strong>convolved</strong> (<em>list</em><em>, </em><em>optional</em>) – on what columns convolution has been performed; defaults to None</p></li>
<li><p><strong>polys</strong> (<em>list</em><em>, </em><em>optional</em>) – list of polynomial terms in design matrix, e.g. intercept, polynomial trends, basis functions, etc; default None</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltools.data.Design_Matrix.add_dct_basis">
<code class="sig-name descname"><span class="pre">add_dct_basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">180</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.add_dct_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.add_dct_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds unit scaled cosine basis functions to Design_Matrix columns,
based on spm-style discrete cosine transform for use in
high-pass filtering. Does not add intercept/constant. Care is recommended if using this along with <cite>.add_poly()</cite>, as some columns will be highly-correlated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<em>int</em>) – length of filter in seconds</p></li>
<li><p><strong>drop</strong> (<em>int</em>) – index of which early/slow bases to drop if any; will always drop constant (i.e. intercept) like SPM. Unlike SPM, retains first basis (i.e. linear/sigmoidal). Will cumulatively drop bases up to and inclusive of index provided (e.g. 2, drops bases 1 and 2); default None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.add_poly">
<code class="sig-name descname"><span class="pre">add_poly</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.add_poly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.add_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Add nth order Legendre polynomial terms as columns to design matrix. Good for adding constant/intercept to model (order = 0) and accounting for slow-frequency nuisance artifacts e.g. linear, quadratic, etc drifts. Care is recommended when using this with <cite>.add_dct_basis()</cite> as some columns will be highly correlated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order</strong> (<em>int</em>) – what order terms to add; 0 = constant/intercept
(default), 1 = linear, 2 = quadratic, etc</p></li>
<li><p><strong>include_lower</strong> – (bool) whether to add lower order terms if order &gt; 0</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.append">
<code class="sig-name descname"><span class="pre">append</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_separate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique_cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for concatenating another design matrix row or column-wise. When concatenating row-wise, has the ability to keep certain columns separated if they exist in multiple design matrices (e.g. keeping separate intercepts for multiple runs). This is on by default and will automatically separate out polynomial columns (i.e. anything added with the <cite>add_poly</cite> or <cite>add_dct_basis</cite> methods). Additional columns can be separate by run using the <cite>unique_cols</cite> parameter. Can also add new polynomial terms during vertical concatentation (when axis == 0). This will by default create new polynomial terms separately for each design matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dm</strong> (<a class="reference internal" href="#nltools.data.Design_Matrix" title="nltools.data.Design_Matrix"><em>Design_Matrix</em></a><em> or </em><em>list</em>) – design_matrix or list of design_matrices to append</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – 0 for row-wise (vert-cat), 1 for column-wise (horz-cat); default 0</p></li>
<li><p><strong>keep_separate</strong> (<em>bool</em><em>,</em><em>optional</em>) – whether try and uniquify columns;
defaults to True; only applies
when axis==0</p></li>
<li><p><strong>unique_cols</strong> (<em>list</em><em>,</em><em>optional</em>) – what additional columns to try to keep
separated by uniquifying, only applies when
axis = 0; defaults to None</p></li>
<li><p><strong>fill_na</strong> (<em>str/int/float</em>) – if provided will fill NaNs with this value during row-wise appending (when axis = 0) if separate columns are desired; default 0</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – print messages during append about how polynomials are going to be separated</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.clean">
<code class="sig-name descname"><span class="pre">clean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fill_na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.clean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to fill NaNs in Design Matrix and remove duplicate columns based on data values, NOT names. Columns are dropped if they are correlated &gt;= the requested threshold (default = .95). In this case, only the first instance of that column will be retained and all others will be dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fill_na</strong> (<em>str/int/float</em>) – value to fill NaNs with set to None to retain NaNs; default 0</p></li>
<li><p><strong>exclude_polys</strong> (<em>bool</em>) – whether to skip checking of polynomial terms (i.e. intercept, trends, basis functions); default False</p></li>
<li><p><strong>thresh</strong> (<em>float</em>) – correlation threshold to use to drop redundant columns; default .95</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – print what column names were dropped; default True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.convolve">
<code class="sig-name descname"><span class="pre">convolve</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">conv_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hrf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.convolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform convolution using an arbitrary function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conv_func</strong> (<em>ndarray</em><em> or </em><em>string</em>) – either a 1d numpy array containing output of a function that you want to convolve; a samples by kernel 2d array of several kernels to convolve; or the string ‘hrf’ which defaults to a glover HRF function at the Design_matrix’s sampling_freq</p></li>
<li><p><strong>columns</strong> (<em>list</em>) – what columns to perform convolution on; defaults
to all non-polynomial columns</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.downsample">
<code class="sig-name descname"><span class="pre">downsample</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.downsample" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Downsample columns of design matrix. Relies on</dt><dd><p>nltools.stats.downsample, but ensures that returned object is a
design matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<em>float</em>) – desired frequency in hz</p></li>
<li><p><strong>kwargs</strong> – additional inputs to nltools.stats.downsample</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.heatmap">
<code class="sig-name descname"><span class="pre">heatmap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.heatmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.heatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize Design Matrix spm style. Use .plot() for typical pandas
plotting functionality. Can pass optional keyword args to seaborn
heatmap.</p>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.replace_data">
<code class="sig-name descname"><span class="pre">replace_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.replace_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.replace_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient method to replace all data in Design_Matrix with new data while keeping attributes and polynomial columns untouched.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>columns_names</strong> (<em>list</em>) – list of columns names for new data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.upsample">
<code class="sig-name descname"><span class="pre">upsample</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.upsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.upsample" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Upsample columns of design matrix. Relies on</dt><dd><p>nltools.stats.upsample, but ensures that returned object is a
design matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<em>float</em>) – desired frequence in hz</p></li>
<li><p><strong>kwargs</strong> – additional inputs to nltools.stats.downsample</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.vif">
<code class="sig-name descname"><span class="pre">vif</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exclude_polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.vif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.vif" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute variance inflation factor amongst columns of design matrix,ignoring polynomial terms. Much faster that statsmodels and more reliable too. Uses the same method as Matlab and R (diagonal elements of the inverted correlation matrix).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list with length == number of columns - intercept
exclude_polys (bool): whether to skip checking of polynomial terms (i.e intercept, trends, basis functions); default True</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>vifs (list)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.data.Design_Matrix.zscore">
<code class="sig-name descname"><span class="pre">zscore</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/data/design_matrix.html#Design_Matrix.zscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.data.Design_Matrix.zscore" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Z-score specific columns of design matrix. Relies on</dt><dd><p>nltools.stats.downsample, but ensures that returned object is a
design matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>columns</strong> (<em>list</em>) – columns to z-score; defaults to all columns</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nltools-analysis-analysis-tools">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.analysis</span></code>: Analysis Tools<a class="headerlink" href="#nltools-analysis-analysis-tools" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="nltools.analysis.Roc">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.analysis.</span></code><code class="sig-name descname"><span class="pre">Roc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'optimal_overall'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forced_choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc" title="Permalink to this definition">¶</a></dt>
<dd><p>Roc Class</p>
<p>The Roc class is based on Tor Wager’s Matlab roc_plot.m function and
allows a user to easily run different types of receiver operator
characteristic curves.  For example, one might be interested in single
interval or forced choice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_values</strong> – nibabel data instance</p></li>
<li><p><strong>binary_outcome</strong> – vector of training labels</p></li>
<li><p><strong>threshold_type</strong> – [‘optimal_overall’, ‘optimal_balanced’,
‘minimum_sdt_bias’]</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltools.analysis.Roc.calculate">
<code class="sig-name descname"><span class="pre">calculate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'optimal_overall'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forced_choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balanced_acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Receiver Operating Characteristic plot (ROC) for
single-interval classification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_values</strong> – nibabel data instance</p></li>
<li><p><strong>binary_outcome</strong> – vector of training labels</p></li>
<li><p><strong>criterion_values</strong> – (optional) criterion values for calculating fpr
&amp; tpr</p></li>
<li><p><strong>threshold_type</strong> – [‘optimal_overall’, ‘optimal_balanced’,
‘minimum_sdt_bias’]</p></li>
<li><p><strong>forced_choice</strong> – index indicating position for each unique subject
(default=None)</p></li>
<li><p><strong>balanced_acc</strong> – balanced accuracy for single-interval classification
(bool). THIS IS NOT COMPLETELY IMPLEMENTED BECAUSE
IT AFFECTS ACCURACY ESTIMATES, BUT NOT P-VALUES OR
THRESHOLD AT WHICH TO EVALUATE SENS/SPEC</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.analysis.Roc.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plot_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balanced_acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc.plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ROC Plot</p>
<p>Create a specific kind of ROC curve plot, based on input values
along a continuous distribution and a binary outcome variable (logical)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plot_method</strong> – type of plot [‘gaussian’,’observed’]</p></li>
<li><p><strong>binary_outcome</strong> – vector of training labels</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction
algorithm</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.analysis.Roc.summary">
<code class="sig-name descname"><span class="pre">summary</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/analysis.html#Roc.summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.analysis.Roc.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a formatted summary of ROC analysis.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltools.stats">
<span id="nltools-stats-stats-tools"></span><h2><a class="reference internal" href="#module-nltools.stats" title="nltools.stats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.stats</span></code></a>: Stats Tools<a class="headerlink" href="#module-nltools.stats" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-statistics-tools">
<h3>NeuroLearn Statistics Tools<a class="headerlink" href="#neurolearn-statistics-tools" title="Permalink to this headline">¶</a></h3>
<p>Tools to help with statistical analyses.</p>
<dl class="py function">
<dt id="nltools.stats.align">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">align</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'deterministic_srm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#align"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align subject data into a common response model.</p>
<p>Can be used to hyperalign source data to target data using
Hyperalignment from Dartmouth (i.e., procrustes transformation; see
nltools.stats.procrustes) or Shared Response Model from Princeton (see
nltools.external.srm). (see nltools.data.Brain_Data.align for aligning
a single Brain object to another). Common Model is shared response
model or centered target data. Transformed data can be back projected to
original data using Tranformation matrix. Inputs must be a list of Brain_Data
instances or numpy arrays (observations by features).</p>
<p class="rubric">Examples</p>
<dl class="simple">
<dt>Hyperalign using procrustes transform:</dt><dd><p>out = align(data, method=’procrustes’)</p>
</dd>
<dt>Align using shared response model:</dt><dd><p>out = align(data, method=’probabilistic_srm’, n_features=None)</p>
</dd>
<dt>Project aligned data into original data:</dt><dd><p>original_data = [np.dot(t.data,tm.T) for t,tm in zip(out[‘transformed’], out[‘transformation_matrix’])]</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (list) A list of Brain_Data objects</p></li>
<li><p><strong>method</strong> – (str) alignment method to use
[‘probabilistic_srm’,’deterministic_srm’,’procrustes’]</p></li>
<li><p><strong>n_features</strong> – (int) number of features to align to common space.
If None then will select number of voxels</p></li>
<li><p><strong>axis</strong> – (int) axis to align on</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(dict) a dictionary containing a list of transformed subject</dt><dd><p>matrices, a list of transformation matrices, the shared
response matrix, and the intersubject correlation of the shared resposnes</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.align_states">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">align_states</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_zero_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#align_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.align_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Align state weight maps using hungarian algorithm by minimizing pairwise distance between group states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> – (np.array) reference pattern x state matrix</p></li>
<li><p><strong>target</strong> – (np.array) target pattern x state matrix to align to reference</p></li>
<li><p><strong>metric</strong> – (str) distance metric to use</p></li>
<li><p><strong>return_index</strong> – (bool) return index if True, return remapped data if False</p></li>
<li><p><strong>replace_zero_variance</strong> – (bool) transform a vector with zero variance to random numbers from a uniform distribution.
Useful for when using correlation as a distance metric to avoid NaNs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(list) a list of reordered state X pattern matrices</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ordered_weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.calc_bpm">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">calc_bpm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beat_interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#calc_bpm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.calc_bpm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate instantaneous BPM from beat to beat interval</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>beat_interval</strong> – (int) number of samples in between each beat
(typically R-R Interval)</p></li>
<li><p><strong>sampling_freq</strong> – (float) sampling frequency in Hz</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float) beats per minute for time interval</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bpm</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.correlation">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">correlation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pearson'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the correlation between data1 and data2</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (np.array) x</p></li>
<li><p><strong>data2</strong> – (np.array) y</p></li>
<li><p><strong>metric</strong> – (str) type of correlation [“spearman” or “pearson” or “kendall”]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(np.array) correlations
p: (float) p-value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>r</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.correlation_permutation">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">correlation_permutation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'permute'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spearman'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#correlation_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.correlation_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute correlation and calculate p-value using permutation methods.</p>
<p>‘permute’ method randomly shuffles one of the vectors. This method is recommended
for independent data. For timeseries data we recommend using ‘circle_shift’ or
‘phase_randomize’ methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (pd.DataFrame, pd.Series, np.array) dataset 1 to permute</p></li>
<li><p><strong>data2</strong> – (pd.DataFrame, pd.Series, np.array) dataset 2 to permute</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,
‘kendall’]</p></li>
<li><p><strong>method</strong> – (str) type of permutation [‘permute’, ‘circle_shift’, ‘phase_randomize’]</p></li>
<li><p><strong>random_state</strong> – (int, None, or np.random.RandomState) Initial random seed (default: None)</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.distance_correlation">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">distance_correlation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias_corrected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ttest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#distance_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.distance_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the distance correlation betwen 2 arrays to test for multivariate dependence (linear or non-linear). Arrays must match on their first dimension. It’s almost always preferable to compute the bias_corrected version which can also optionally perform a ttest. This ttest operates on a statistic thats ~dcorr^2 and will be also returned.</p>
<p>Explanation:
Distance correlation involves computing the normalized covariance of two centered euclidean distance matrices. Each distance matrix is the euclidean distance between rows (if x or y are 2d) or scalars (if x or y are 1d). Each matrix is centered prior to computing the covariance either using double-centering or u-centering, which corrects for bias as the number of dimensions increases. U-centering is almost always preferred in all cases. It also permits inference of the normalized covariance between each distance matrix using a one-tailed directional t-test. (Szekely &amp; Rizzo, 2013). While distance correlation is normally bounded between 0 and 1, u-centering can produce negative estimates, which are never significant.</p>
<p>Validated against the dcor and dcor.ttest functions in the ‘energy’ R package and the dcor.distance_correlation, dcor.udistance_correlation_sqr, and dcor.independence.distance_correlation_t_test functions in the dcor Python package.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – 1d or 2d numpy array of observations by features</p></li>
<li><p><strong>y</strong> (<em>ndarry</em>) – 1d or 2d numpy array of observations by features</p></li>
<li><p><strong>bias_corrected</strong> (<em>bool</em>) – if false use double-centering which produces a biased-estimate that converges to 1 as the number of dimensions increase. Otherwise used u-centering to correct this bias. <strong>Note</strong> this must be True if ttest=True; default True</p></li>
<li><p><strong>ttest</strong> (<em>bool</em>) – perform a ttest using the bias_corrected distance correlation; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary of results (correlation, t, p, and df.) Optionally, covariance, x variance, and y variance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>results (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.double_center">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">double_center</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#double_center"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.double_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Double center a 2d array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>ndarray</em>) – 2d numpy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>double-centered version of input</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mat (ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.downsample">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">downsample</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'samples'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample pandas to a new target frequency or number of samples
using averaging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to downsample</p></li>
<li><p><strong>sampling_freq</strong> – (float) Sampling frequency of data in hertz</p></li>
<li><p><strong>target</strong> – (float) downsampling target</p></li>
<li><p><strong>target_type</strong> – type of target can be [samples,seconds,hz]</p></li>
<li><p><strong>method</strong> – (str) type of downsample method [‘mean’,’median’],
default: mean</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame, pd.Series) downsmapled data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.fdr">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">fdr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#fdr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine FDR threshold given a p value array and desired false
discovery rate q. Written by Tal Yarkoni</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – (np.array) vector of p-values</p></li>
<li><p><strong>q</strong> – (float) false discovery rate level</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(float) p-value threshold based on independence or positive</dt><dd><p>dependence</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fdr_p</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.find_spikes">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">find_spikes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_spike_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#find_spikes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.find_spikes" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to identify spikes from fMRI Time Series Data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Brain_Data or nibabel instance</p></li>
<li><p><strong>global_spike_cutoff</strong> – (int,None) cutoff to identify spikes in global signal
in standard deviations, None indicates do not calculate.</p></li>
<li><p><strong>diff_spike_cutoff</strong> – (int,None) cutoff to identify spikes in average frame difference
in standard deviations, None indicates do not calculate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>pandas dataframe with spikes as indicator variables</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.fisher_r_to_z">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">fisher_r_to_z</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#fisher_r_to_z"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.fisher_r_to_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Fisher transformation to convert correlation to z score</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.fisher_z_to_r">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">fisher_z_to_r</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#fisher_z_to_r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.fisher_z_to_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Fisher transformation to convert correlation to z score</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.holm_bonf">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">holm_bonf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#holm_bonf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.holm_bonf" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute corrected p-values based on the Holm-Bonferroni method, i.e. step-down procedure applying iteratively less correction to highest p-values. A bit more conservative than fdr, but much more powerful thanvanilla bonferroni.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – (np.array) vector of p-values</p></li>
<li><p><strong>alpha</strong> – (float) alpha level</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(float) p-value threshold based on bonferroni</dt><dd><p>step-down procedure</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bonf_p</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.isc">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">isc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bootstraps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bootstrap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_self_corr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_bootstraps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute pairwise intersubject correlation from observations by subjects array.</p>
<p>This function computes pairwise intersubject correlations (ISC) using the median as recommended by Chen
et al., 2016). However, if the mean is preferred, we compute the mean correlation after performing
the fisher r-to-z transformation and then convert back to correlations to minimize artificially
inflating the correlation values.</p>
<p>There are currently three different methods to compute p-values. These include the classic methods for
computing permuted time-series by either circle-shifting the data or phase-randomizing the data
(see Lancaster et al., 2018). These methods create random surrogate data while preserving the temporal
autocorrelation inherent to the signal. By default, we use the subject-wise bootstrap method from
Chen et al., 2016. Instead of recomputing the pairwise ISC using circle_shift or phase_randomization methods,
this approach uses the computationally more efficient method of bootstrapping the subjects
and computing a new pairwise similarity matrix with randomly selected subjects with replacement.
If the same subject is selected multiple times, we set the perfect correlation to a nan with
(exclude_self_corr=True). We compute the p-values using the percentile method using the same
method in Brainiak.</p>
<p>Chen, G., Shin, Y. W., Taylor, P. A., Glen, D. R., Reynolds, R. C., Israel, R. B.,
&amp; Cox, R. W. (2016). Untangling the relatedness among correlations, part I:
nonparametric approaches to inter-subject correlation analysis at the group level.
NeuroImage, 142, 248-259.</p>
<p>Hall, P., &amp; Wilson, S. R. (1991). Two guidelines for bootstrap hypothesis testing.
Biometrics, 757-762.</p>
<p>Lancaster, G., Iatsenko, D., Pidde, A., Ticcinelli, V., &amp; Stefanovska, A. (2018).
Surrogate data for hypothesis testing of physical systems. Physics Reports, 748, 1-60.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, np.array) observations by subjects where isc is computed across subjects</p></li>
<li><p><strong>n_bootstraps</strong> – (int) number of bootstraps</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,’kendall’]</p></li>
<li><p><strong>method</strong> – (str) method to compute p-values [‘bootstrap’, ‘circle_shift’,’phase_randomize’] (default: bootstrap)</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation. -1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.isfc">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">isfc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'average'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isfc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute intersubject functional connectivity (ISFC) from a list of observation x feature matrices</p>
<p>This function uses the leave one out approach to compute ISFC (Simony et al., 2016).
For each subject, compute the cross-correlation between each voxel/roi
with the average of the rest of the subjects data. In other words,
compute the mean voxel/ROI response for all participants except the
target subject. Then compute the correlation between each ROI within
the target subject with the mean ROI response in the group average.</p>
<p>Simony, E., Honey, C. J., Chen, J., Lositsky, O., Yeshurun, Y., Wiesel, A., &amp; Hasson, U. (2016).
Dynamic reconfiguration of the default mode network during narrative comprehension.
Nature communications, 7, 12141.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – list of subject matrices (observations x voxels/rois)</p></li>
<li><p><strong>method</strong> – approach to computing ISFC. ‘average’ uses leave one</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of subject ISFC matrices</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.isps">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">isps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.04</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pairwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#isps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.isps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Dynamic Intersubject Phase Synchrony (ISPS from a observation by subject array)</p>
<p>This function computes the instantaneous intersubject phase synchrony for a single voxel/roi
timeseries. Requires multiple subjects. This method is largely based on that described by Glerean
et al., 2012 and performs a hilbert transform on narrow bandpass filtered timeseries (butterworth)
data to get the instantaneous phase angle. The function returns a dictionary containing the
average phase angle, the average vector length, and parametric p-values computed using the rayleigh test using circular
statistics (Fisher, 1993). If pairwise=True, then it will compute these on the pairwise phase angle differences,
if pairwise=False, it will compute these on the actual phase angles. This is called inter-site phase coupling
or inter-trial phase coupling respectively in the EEG literatures.</p>
<p>This function requires narrow band filtering your data. As a default we use the recommendations
by (Glerean et al., 2012) of .04-.07Hz. This is similar to the “slow-4” band (0.025–0.067 Hz)
described by (Zuo et al., 2010; Penttonen &amp; Buzsáki, 2003), but excludes the .03 band, which has been
demonstrated to contain aliased respiration signals (Birn, 2006).</p>
<p>Birn RM, Smith MA, Bandettini PA, Diamond JB. 2006. Separating respiratory-variation-related
fluctuations from neuronal-activity- related fluctuations in fMRI. Neuroimage 31:1536–1548.</p>
<p>Buzsáki, G., &amp; Draguhn, A. (2004). Neuronal oscillations in cortical networks. Science,
304(5679), 1926-1929.</p>
<p>Fisher, N. I. (1995). Statistical analysis of circular data. cambridge university press.</p>
<p>Glerean, E., Salmi, J., Lahnakoski, J. M., Jääskeläinen, I. P., &amp; Sams, M. (2012).
Functional magnetic resonance imaging phase synchronization as a measure of dynamic
functional connectivity. Brain connectivity, 2(2), 91-101.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, np.ndarray) observations x subjects data</p></li>
<li><p><strong>sampling_freq</strong> – (float) sampling freqency of data in Hz</p></li>
<li><p><strong>low_cut</strong> – (float) lower bound cutoff for high pass filter</p></li>
<li><p><strong>high_cut</strong> – (float) upper bound cutoff for low pass filter</p></li>
<li><p><strong>order</strong> – (int) filter order for butterworth bandpass</p></li>
<li><p><strong>pairwise</strong> – (bool) compute phase angle coherence on pairwise phase angle differences
or on raw phase angle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary with mean phase angle, vector length, and rayleigh statistic</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.make_cosine_basis">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">make_cosine_basis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsamples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#make_cosine_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.make_cosine_basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Create a series of cosine basis functions for a discrete cosine</dt><dd><p>transform. Based off of implementation in spm_filter and spm_dctmtx
because scipy dct can only apply transforms but not return the basis
functions. Like SPM, does not add constant (i.e. intercept), but does
retain first basis (i.e. sigmoidal/linear drift)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsamples</strong> (<em>int</em>) – number of observations (e.g. TRs)</p></li>
<li><p><strong>sampling_freq</strong> (<em>float</em>) – sampling frequency in hertz (i.e. 1 / TR)</p></li>
<li><p><strong>filter_length</strong> (<em>int</em>) – length of filter in seconds</p></li>
<li><p><strong>unit_scale</strong> (<em>true</em>) – assure that the basis functions are on the normalized range [-1, 1]; default True</p></li>
<li><p><strong>drop</strong> (<em>int</em>) – index of which early/slow bases to drop if any; default is
to drop constant (i.e. intercept) like SPM. Unlike SPM, retains
first basis (i.e. linear/sigmoidal). Will cumulatively drop bases
up to and inclusive of index provided (e.g. 2, drops bases 1 and 2)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>nsamples x number of basis sets numpy array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out (ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.matrix_permutation">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">matrix_permutation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spearman'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#matrix_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.matrix_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute 2-dimensional matrix correlation (mantel test).</p>
<p>Chen, G. et al. (2016). Untangling the relatedness among correlations,
part I: nonparametric approaches to inter-subject correlation analysis
at the group level. Neuroimage, 142, 248-259.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (pd.DataFrame, np.array) square matrix</p></li>
<li><p><strong>data2</strong> – (pd.DataFrame, np.array) square matrix</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>metric</strong> – (str) type of association metric [‘spearman’,’pearson’,
‘kendall’]</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test
(default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘correlation’,’p’]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.multi_threshold">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">multi_threshold</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#multi_threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.multi_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold test image by multiple p-value from p image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stat</strong> – (Brain_Data) Brain_Data instance of arbitrary statistic metric
(e.g., beta, t, etc)</p></li>
<li><p><strong>p</strong> – (Brain_Data) Brain_data instance of p-values</p></li>
<li><p><strong>threshold</strong> – (list) list of p-values to threshold stat image</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Thresholded Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.one_sample_permutation">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">one_sample_permutation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#one_sample_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.one_sample_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>One sample permutation test using randomization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series, np.array) data to permute</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
<li><p><strong>random_state</strong> – (int, None, or np.random.RandomState) Initial random seed (default: None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘mean’,’p’]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.pearson">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">pearson</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#pearson"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.pearson" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlates row vector x with each row vector in 2D array y.
From neurosynth.stats.py - author: Tal Yarkoni</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.procrustes">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">procrustes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#procrustes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Procrustes analysis, a similarity test for two data sets.</p>
<p>Each input matrix is a set of points or vectors (the rows of the matrix).
The dimension of the space is the number of columns of each matrix. Given
two identically sized matrices, procrustes standardizes both such that:
- <span class="math notranslate nohighlight">\(tr(AA^{T}) = 1\)</span>.
- Both sets of points are centered around the origin.
Procrustes (<a href="#id4"><span class="problematic" id="id1">[1]_</span></a>, <a href="#id5"><span class="problematic" id="id2">[2]_</span></a>) then applies the optimal transform to the second
matrix (including scaling/dilation, rotations, and reflections) to minimize
<span class="math notranslate nohighlight">\(M^{2}=\sum(data1-data2)^{2}\)</span>, or the sum of the squares of the
pointwise differences between the two input datasets.
This function was not designed to handle datasets with different numbers of
datapoints (rows).  If two data sets have different dimensionality
(different number of columns), this function will add columns of zeros to
the smaller of the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – array_like
Matrix, n rows represent points in k (columns) space <cite>data1</cite> is the
reference data, after it is standardised, the data from <cite>data2</cite>
will be transformed to fit the pattern in <cite>data1</cite> (must have &gt;1
unique points).</p></li>
<li><p><strong>data2</strong> – array_like
n rows of data in k space to be fit to <cite>data1</cite>.  Must be the  same
shape <code class="docutils literal notranslate"><span class="pre">(numrows,</span> <span class="pre">numcols)</span></code> as data1 (must have &gt;1 unique points).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>array_like</dt><dd><p>A standardized version of <cite>data1</cite>.</p>
</dd>
<dt>mtx2<span class="classifier">array_like</span></dt><dd><p>The orientation of <cite>data2</cite> that best fits <cite>data1</cite>. Centered, but not
necessarily <span class="math notranslate nohighlight">\(tr(AA^{T}) = 1\)</span>.</p>
</dd>
<dt>disparity<span class="classifier">float</span></dt><dd><p><span class="math notranslate nohighlight">\(M^{2}\)</span> as defined above.</p>
</dd>
<dt>R<span class="classifier">(N, N) ndarray</span></dt><dd><p>The matrix solution of the orthogonal Procrustes problem.
Minimizes the Frobenius norm of dot(data1, R) - data2, subject to
dot(R.T, R) == I.</p>
</dd>
<dt>scale<span class="classifier">float</span></dt><dd><p>Sum of the singular values of <code class="docutils literal notranslate"><span class="pre">dot(data1.T,</span> <span class="pre">data2)</span></code>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mtx1</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.procrustes_distance">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">procrustes_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#procrustes_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.procrustes_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Use procrustes super-position to perform a similarity test between 2 matrices. Matrices need to match in size on their first dimension only, as the smaller matrix on the second dimension will be padded with zeros. After aligning two matrices using the procrustes transformation, use the computed disparity between them (sum of squared error of elements) as a similarity metric. Shuffle the rows of one of the matrices and recompute the disparity to perform inference (Peres-Neto &amp; Jackson, 2001).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat1</strong> (<em>ndarray</em>) – 2d numpy array; must have same number of rows as mat2</p></li>
<li><p><strong>mat2</strong> (<em>ndarray</em>) – 1d or 2d numpy array; must have same number of rows as mat1</p></li>
<li><p><strong>n_permute</strong> (<em>int</em>) – number of permutation iterations to perform</p></li>
<li><p><strong>tail</strong> (<em>int</em>) – either 1 for one-tailed or 2 for two-tailed test; default 2</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of CPUs to use to do permutation; default -1 (all)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>similarity between matrices bounded between 0 and 1
pval (float): permuted p-value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>similarity (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.regress">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">regress</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ols'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#regress"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a flexible function to run several types of regression models provided X and Y numpy arrays. Y can be a 1d numpy array or 2d numpy array. In the latter case, results will be output with shape 1 x Y.shape[1], in other words fitting a separate regression model to each column of Y.</p>
<p>Does NOT add an intercept automatically to the X matrix before fitting like some other software packages. This is left up to the user.</p>
<p>This function can compute regression in 3 ways:
1) Standard OLS
2) OLS with robust sandwich estimators for standard errors. 3 robust types of estimators exist:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>‘hc0’ - classic huber-white estimator robust to heteroscedasticity (default)</p></li>
<li><p>‘hc3’ - a variant on huber-white estimator slightly more conservative when sample sizes are small</p></li>
<li><p>‘hac’ - an estimator robust to both heteroscedasticity and auto-correlation; auto-correlation lag can be controlled with the ‘nlags’ keyword argument; default is 1</p></li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>ARMA (auto-regressive moving-average) model (experimental). This model is fit through statsmodels.tsa.arima_model.ARMA, so more information about options can be found there. Any settings can be passed in as kwargs. By default fits a (1,1) model with starting lags of 2. This mode is <strong>computationally intensive</strong> and can take quite a while if Y has many columns.  If Y is a 2d array joblib.Parallel is used for faster fitting by parallelizing fits across columns of Y. Parallelization can be controlled by passing in kwargs. Defaults to multi-threading using 10 separate threads, as threads don’t require large arrays to be duplicated in memory. Defaults are also set to enable memory-mapping for very large arrays if backend=’multiprocessing’ to prevent crashes and hangs. Various levels of progress can be monitored using the ‘disp’ (statsmodels) and ‘verbose’ (joblib) keyword arguments with integer values &gt; 0.</p></li>
</ol>
<p class="rubric">Examples</p>
<p>Standard OLS</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ols&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Robust OLS with heteroscedasticity (hc0) robust standard errors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;robust&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Robust OLS with heteroscedasticty and auto-correlation (with lag 2) robust standard errors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;robust&#39;</span><span class="p">,</span><span class="n">robust_estimator</span><span class="o">=</span><span class="s1">&#39;hac&#39;</span><span class="p">,</span><span class="n">nlags</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Auto-regressive mode with auto-regressive and moving-average lags = 1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;arma&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Auto-regressive model with auto-regressive lag = 2, moving-average lag = 3, and multi-processing instead of multi-threading using 8 cores (this can use a lot of memory if input arrays are very large!).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;arma&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">backend</span><span class="o">=</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – design matrix; assumes intercept is included</p></li>
<li><p><strong>Y</strong> (<em>ndarray</em>) – dependent variable array; if 2d, a model is fit to each column of Y separately</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – kind of model to fit; must be one of ‘ols’ (default), ‘robust’, or ‘arma’</p></li>
<li><p><strong>robust_estimator</strong> (<em>str</em><em>,</em><em>optional</em>) – kind of robust estimator to use if mode = ‘robust’; default ‘hc0’</p></li>
<li><p><strong>nlags</strong> (<em>int</em><em>,</em><em>optional</em>) – auto-correlation lag correction if mode = ‘robust’ and robust_estimator = ‘hac’; default 1</p></li>
<li><p><strong>order</strong> (<em>tuple</em><em>,</em><em>optional</em>) – auto-regressive and moving-average orders for mode = ‘arma’; default (1,1)</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – additional keyword arguments to statsmodels.tsa.arima_model.ARMA and joblib.Parallel</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>coefficients
t: t-statistics (coef/sterr)
p : p-values
df: degrees of freedom
res: residuals</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>b</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.summarize_bootstrap">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">summarize_bootstrap</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#summarize_bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.summarize_bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate summary of bootstrap samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample</strong> – (Brain_Data) Brain_Data instance of samples</p></li>
<li><p><strong>save_weights</strong> – (bool) save bootstrap weights</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of Brain_Data summary images</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>output</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.threshold">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">threshold</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold test image by p-value from p image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stat</strong> – (Brain_Data) Brain_Data instance of arbitrary statistic metric
(e.g., beta, t, etc)</p></li>
<li><p><strong>p</strong> – (Brain_Data) Brain_data instance of p-values</p></li>
<li><p><strong>threshold</strong> – (float) p-value to threshold stat image</p></li>
<li><p><strong>return_mask</strong> – (bool) optionall return the thresholding mask; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Thresholded Brain_Data instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.transform_pairwise">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">transform_pairwise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#transform_pairwise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.transform_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms data into pairs with balanced labels for ranking
Transforms a n-class ranking problem into a two-class classification
problem. Subclasses implementing particular strategies for choosing
pairs should override this method.
In this method, all pairs are choosen, except for those that have the
same target value. The output is an array of balanced classes, i.e.
there are the same number of -1 as +1</p>
<p>Reference: “Large Margin Rank Boundaries for Ordinal Regression”,
R. Herbrich, T. Graepel, K. Obermayer.
Authors: Fabian Pedregosa &lt;<a class="reference external" href="mailto:fabian&#37;&#52;&#48;fseoane&#46;net">fabian<span>&#64;</span>fseoane<span>&#46;</span>net</a>&gt;</p>
<blockquote>
<div><p>Alexandre Gramfort &lt;<a class="reference external" href="mailto:alexandre&#46;gramfort&#37;&#52;&#48;inria&#46;fr">alexandre<span>&#46;</span>gramfort<span>&#64;</span>inria<span>&#46;</span>fr</a>&gt;</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – (np.array), shape (n_samples, n_features)
The data</p></li>
<li><p><strong>y</strong> – (np.array), shape (n_samples,) or (n_samples, 2)
Target labels. If it’s a 2D array, the second column represents
the grouping of samples, i.e., samples with different groups will
not be considered.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(np.array), shape (k, n_feaures)</dt><dd><p>Data as pairs, where k = n_samples * (n_samples-1)) / 2 if grouping
values were not passed. If grouping variables exist, then returns
values computed for each group.</p>
</dd>
<dt>y_trans: (np.array), shape (k,)</dt><dd><p>Output class labels, where classes have values {-1, +1}
If y was shape (n_samples, 2), then returns (k, 2) with groups on
the second dimension.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>X_trans</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.trim">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">trim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#trim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim a Pandas DataFrame or Series by replacing outlier values with NaNs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to trim</p></li>
<li><p><strong>cutoff</strong> – (dict) a dictionary with keys {‘std’:[low,high]} or
{‘quantile’:[low,high]}</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame, pd.Series) trimmed data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.two_sample_permutation">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">two_sample_permutation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#two_sample_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.two_sample_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Independent sample permutation test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data1</strong> – (pd.DataFrame, pd.Series, np.array) dataset 1 to permute</p></li>
<li><p><strong>data2</strong> – (pd.DataFrame, pd.Series, np.array) dataset 2 to permute</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations</p></li>
<li><p><strong>tail</strong> – (int) either 1 for one-tail or 2 for two-tailed test (default: 2)</p></li>
<li><p><strong>n_jobs</strong> – (int) The number of CPUs to use to do the computation.
-1 means all CPUs.</p></li>
<li><p><strong>return_parms</strong> – (bool) Return the permutation distribution along with the p-value; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(dict) dictionary of permutation results [‘mean’,’p’]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>stats</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.u_center">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">u_center</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#u_center"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.u_center" title="Permalink to this definition">¶</a></dt>
<dd><p>U-center a 2d array. U-centering is a bias-corrected form of double-centering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>ndarray</em>) – 2d numpy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>u-centered version of input</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>mat (narray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.upsample">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">upsample</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'samples'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#upsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.upsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample pandas to a new target frequency or number of samples using interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to upsample
(Note: will drop non-numeric columns from DataFrame)</p></li>
<li><p><strong>sampling_freq</strong> – Sampling frequency of data in hertz</p></li>
<li><p><strong>target</strong> – (float) upsampling target</p></li>
<li><p><strong>target_type</strong> – (str) type of target can be [samples,seconds,hz]</p></li>
<li><p><strong>method</strong> – (str) [‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’]
where ‘zero’, ‘slinear’, ‘quadratic’ and ‘cubic’
refer to a spline interpolation of zeroth, first,
second or third order  (default: linear)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>upsampled pandas object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.winsorize">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">winsorize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_with_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#winsorize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.winsorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Winsorize a Pandas DataFrame or Series with the largest/lowest value not considered outlier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – (pd.DataFrame, pd.Series) data to winsorize</p></li>
<li><p><strong>cutoff</strong> – (dict) a dictionary with keys {‘std’:[low,high]} or
{‘quantile’:[low,high]}</p></li>
<li><p><strong>replace_with_cutoff</strong> – (bool) If True, replace outliers with cutoff.
If False, replaces outliers with closest
existing values; (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame, pd.Series) winsorized data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.stats.zscore">
<code class="sig-prename descclassname"><span class="pre">nltools.stats.</span></code><code class="sig-name descname"><span class="pre">zscore</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/stats.html#zscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.stats.zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>zscore every column in a pandas dataframe or series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>df</strong> – (pd.DataFrame) Pandas DataFrame instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame) z-scored pandas DataFrame or series instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>z_data</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-nltools.datasets">
<span id="nltools-datasets-dataset-tools"></span><h2><a class="reference internal" href="#module-nltools.datasets" title="nltools.datasets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.datasets</span></code></a>: Dataset Tools<a class="headerlink" href="#module-nltools.datasets" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-datasets">
<h3>NeuroLearn datasets<a class="headerlink" href="#neurolearn-datasets" title="Permalink to this headline">¶</a></h3>
<p>functions to help download datasets</p>
<dl class="py function">
<dt id="nltools.datasets.download_collection">
<code class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></code><code class="sig-name descname"><span class="pre">download_collection</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#download_collection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.download_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Download images and metadata from Neurovault collection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection</strong> (<em>int</em><em>, </em><em>optional</em>) – collection id. Defaults to None.</p></li>
<li><p><strong>data_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – data directory. Defaults to None.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em><em>, </em><em>optional</em>) – overwrite data directory. Defaults to False.</p></li>
<li><p><strong>resume</strong> (<em>bool</em><em>, </em><em>optional</em>) – resume download. Defaults to True.</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em>) – print diagnostic messages. Defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(DataFrame of image metadata, list of files from downloaded collection)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(pd.DataFrame, list)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.datasets.download_nifti">
<code class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></code><code class="sig-name descname"><span class="pre">download_nifti</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#download_nifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.download_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Download a image to a nifti file.</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.datasets.fetch_emotion_ratings">
<code class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></code><code class="sig-name descname"><span class="pre">fetch_emotion_ratings</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#fetch_emotion_ratings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.fetch_emotion_ratings" title="Permalink to this definition">¶</a></dt>
<dd><p>Download and loads emotion rating dataset from neurovault</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_dir</strong> – (string, optional). Path of the data directory. Used to force data storage in a specified location. Default: None</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Brain_Data) Brain_Data object with downloaded data. X=metadata</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.datasets.fetch_pain">
<code class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></code><code class="sig-name descname"><span class="pre">fetch_pain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resume</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#fetch_pain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.fetch_pain" title="Permalink to this definition">¶</a></dt>
<dd><p>Download and loads pain dataset from neurovault</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data_dir</strong> – (string, optional) Path of the data directory. Used to force data storage in a specified location. Default: None</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(Brain_Data) Brain_Data object with downloaded data. X=metadata</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.datasets.get_collection_image_metadata">
<code class="sig-prename descclassname"><span class="pre">nltools.datasets.</span></code><code class="sig-name descname"><span class="pre">get_collection_image_metadata</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/datasets.html#get_collection_image_metadata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.datasets.get_collection_image_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get image metadata associated with collection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection</strong> (<em>int</em><em>, </em><em>optional</em>) – collection id. Defaults to None.</p></li>
<li><p><strong>data_dir</strong> (<em>str</em><em>, </em><em>optional</em>) – data directory. Defaults to None.</p></li>
<li><p><strong>limit</strong> (<em>int</em><em>, </em><em>optional</em>) – number of images to increment. Defaults to 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dataframe with full image metadata from collection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-nltools.cross_validation">
<span id="nltools-cross-validation-cross-validation-tools"></span><h2><a class="reference internal" href="#module-nltools.cross_validation" title="nltools.cross_validation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.cross_validation</span></code></a>: Cross-Validation Tools<a class="headerlink" href="#module-nltools.cross_validation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cross-validation-data-classes">
<h3>Cross-Validation Data Classes<a class="headerlink" href="#cross-validation-data-classes" title="Permalink to this headline">¶</a></h3>
<p>Scikit-learn compatible classes for performing various
types of cross-validation</p>
<dl class="py class">
<dt id="nltools.cross_validation.KFoldStratified">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.cross_validation.</span></code><code class="sig-name descname"><span class="pre">KFoldStratified</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.cross_validation.KFoldStratified" title="Permalink to this definition">¶</a></dt>
<dd><p>K-Folds cross validation iterator which stratifies continuous data
(unlike scikit-learn equivalent).</p>
<p>Provides train/test indices to split data in train test sets. Split
dataset into k consecutive folds while ensuring that same subject is
held out within each fold.  Each fold is then used a validation set
once while the k - 1 remaining folds form the training set.
Extension of KFold from scikit-learn cross_validation model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_splits</strong> – int, default=3
Number of folds. Must be at least 2.</p></li>
<li><p><strong>shuffle</strong> – boolean, optional
Whether to shuffle the data before splitting into batches.</p></li>
<li><p><strong>random_state</strong> – None, int or RandomState
Pseudo-random number generator state used for random
sampling. If None, use default numpy RNG for shuffling</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltools.cross_validation.KFoldStratified.split">
<code class="sig-name descname"><span class="pre">split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.cross_validation.KFoldStratified.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate indices to split data into training and test set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – array-like, shape (n_samples, n_features)
Training data, where n_samples is the number of samples
and n_features is the number of features.
Note that providing <code class="docutils literal notranslate"><span class="pre">y</span></code> is sufficient to generate the splits
and hence <code class="docutils literal notranslate"><span class="pre">np.zeros(n_samples)</span></code> may be used as a placeholder
for <code class="docutils literal notranslate"><span class="pre">X</span></code> instead of actual training data.</p></li>
<li><p><strong>y</strong> – array-like, shape (n_samples,)
The target variable for supervised learning problems.
Stratification is done based on the y labels.</p></li>
<li><p><strong>groups</strong> – (object) Always ignored, exists for compatibility.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(ndarray) The training set indices for that split.
test : (ndarray) The testing set indices for that split.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>train</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="nltools.cross_validation.set_cv">
<code class="sig-prename descclassname"><span class="pre">nltools.cross_validation.</span></code><code class="sig-name descname"><span class="pre">set_cv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_generator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#set_cv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.cross_validation.set_cv" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to create a sci-kit learn compatible cv object using
common parameters for prediction analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> – (pd.DataFrame) Pandas Dataframe of Y labels</p></li>
<li><p><strong>cv_dict</strong> – (dict) Type of cross_validation to use. A dictionary of
{‘type’: ‘kfolds’, ‘n_folds’: n},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘stratified’: Y},
{‘type’: ‘kfolds’, ‘n_folds’: n, ‘subject_id’: holdout}, or
{‘type’: ‘loso’, ‘subject_id’: holdout}</p></li>
<li><p><strong>return_generator</strong> (<em>bool</em>) – return a cv generator instead of an instance; default True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a scikit-learn model-selection generator</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>cv</p>
</dd>
</dl>
</dd></dl>

</div>
<dl class="py class">
<dt id="id0">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.cross_validation.</span></code><code class="sig-name descname"><span class="pre">KFoldStratified</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>K-Folds cross validation iterator which stratifies continuous data
(unlike scikit-learn equivalent).</p>
<p>Provides train/test indices to split data in train test sets. Split
dataset into k consecutive folds while ensuring that same subject is
held out within each fold.  Each fold is then used a validation set
once while the k - 1 remaining folds form the training set.
Extension of KFold from scikit-learn cross_validation model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_splits</strong> – int, default=3
Number of folds. Must be at least 2.</p></li>
<li><p><strong>shuffle</strong> – boolean, optional
Whether to shuffle the data before splitting into batches.</p></li>
<li><p><strong>random_state</strong> – None, int or RandomState
Pseudo-random number generator state used for random
sampling. If None, use default numpy RNG for shuffling</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="id3">
<code class="sig-name descname"><span class="pre">split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/cross_validation.html#KFoldStratified.split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate indices to split data into training and test set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – array-like, shape (n_samples, n_features)
Training data, where n_samples is the number of samples
and n_features is the number of features.
Note that providing <code class="docutils literal notranslate"><span class="pre">y</span></code> is sufficient to generate the splits
and hence <code class="docutils literal notranslate"><span class="pre">np.zeros(n_samples)</span></code> may be used as a placeholder
for <code class="docutils literal notranslate"><span class="pre">X</span></code> instead of actual training data.</p></li>
<li><p><strong>y</strong> – array-like, shape (n_samples,)
The target variable for supervised learning problems.
Stratification is done based on the y labels.</p></li>
<li><p><strong>groups</strong> – (object) Always ignored, exists for compatibility.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(ndarray) The training set indices for that split.
test : (ndarray) The testing set indices for that split.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>train</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltools.mask">
<span id="nltools-mask-mask-tools"></span><h2><a class="reference internal" href="#module-nltools.mask" title="nltools.mask"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.mask</span></code></a>: Mask Tools<a class="headerlink" href="#module-nltools.mask" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-mask-classes">
<h3>NeuroLearn Mask Classes<a class="headerlink" href="#neurolearn-mask-classes" title="Permalink to this headline">¶</a></h3>
<p>Classes to represent masks</p>
<dl class="py function">
<dt id="nltools.mask.collapse_mask">
<code class="sig-prename descclassname"><span class="pre">nltools.mask.</span></code><code class="sig-name descname"><span class="pre">collapse_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#collapse_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.collapse_mask" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>collapse separate masks into one mask with multiple integers</dt><dd><p>overlapping areas are ignored</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – nibabel or Brain_Data instance</p></li>
<li><p><strong>custom_mask</strong> – nibabel instance or string to file path; optional</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Brain_Data instance of a mask with different integers indicating</dt><dd><p>different masks</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.mask.create_sphere">
<code class="sig-prename descclassname"><span class="pre">nltools.mask.</span></code><code class="sig-name descname"><span class="pre">create_sphere</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#create_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.create_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a set of spheres in the brain mask space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if
len(radius) &gt; 1</p></li>
<li><p><strong>centers</strong> – a vector of sphere centers of the form [px, py, pz] or
[[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.mask.expand_mask">
<code class="sig-prename descclassname"><span class="pre">nltools.mask.</span></code><code class="sig-name descname"><span class="pre">expand_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#expand_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.expand_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>expand a mask with multiple integers into separate binary masks</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> – nibabel or Brain_Data instance</p></li>
<li><p><strong>custom_mask</strong> – nibabel instance or string to file path; optional</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Brain_Data instance of multiple binary masks</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.mask.roi_to_brain">
<code class="sig-prename descclassname"><span class="pre">nltools.mask.</span></code><code class="sig-name descname"><span class="pre">roi_to_brain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/mask.html#roi_to_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.mask.roi_to_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will create convert an expanded binary mask of ROIs
(see expand_mask) based on a vector of of values. The dataframe of values
must correspond to ROI numbers.</p>
<p>This is useful for populating a parcellation scheme by a vector of Values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – Pandas series, dataframe, list, np.array of ROI by observation</p></li>
<li><p><strong>mask_x</strong> – an expanded binary mask</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>(Brain_Data) Brain_Data instance where each ROI is now populated</dt><dd><p>with a value</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-nltools.file_reader">
<span id="nltools-file-reader-file-reading"></span><h2><a class="reference internal" href="#module-nltools.file_reader" title="nltools.file_reader"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.file_reader</span></code></a>: File Reading<a class="headerlink" href="#module-nltools.file_reader" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-file-reading-tools">
<h3>NeuroLearn File Reading Tools<a class="headerlink" href="#neurolearn-file-reading-tools" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="nltools.file_reader.onsets_to_dm">
<code class="sig-prename descclassname"><span class="pre">nltools.file_reader.</span></code><code class="sig-name descname"><span class="pre">onsets_to_dm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'infer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_separate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_poly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique_cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/file_reader.html#onsets_to_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.file_reader.onsets_to_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can assist in reading in one or several in a 2-3 column onsets files, specified in seconds and converting it to a Design Matrix organized as samples X Stimulus Classes. sampling_freq should be specified in hertz; for TRs use hertz = 1/TR. Onsets files <strong>must</strong> be organized with columns in one of the following 4 formats:</p>
<ol class="arabic simple">
<li><p>‘Stim, Onset’</p></li>
<li><p>‘Onset, Stim’</p></li>
<li><p>‘Stim, Onset, Duration’</p></li>
<li><p>‘Onset, Duration, Stim’</p></li>
</ol>
<p>No other file organizations are currently supported. <em>Note:</em> Stimulus offsets (onset + duration) that fall into an adjacent TR include that full TR. E.g. offset of 10.16s with TR = 2 has an offset of TR 5, which spans 10-12s, rather than an offset of TR 4, which spans 8-10s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>filepath/DataFrame/list</em>) – path to file, pandas dataframe, or list of files or pandas dataframes</p></li>
<li><p><strong>sampling_freq</strong> (<em>float</em>) – sampling frequency in hertz; for TRs use (1 / TR)         run_length (int): number of TRs in the run these onsets came from</p></li>
<li><p><strong>sort</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to sort the columns of the resulting
design matrix alphabetically; defaults to
False</p></li>
<li><p><strong>(</strong><strong>int</strong><strong>, </strong><strong>optional</strong> (<em>addpoly</em>) – what order polynomial terms to add as new columns (e.g. 0 for intercept, 1 for linear trend and intercept, etc); defaults to None</p></li>
<li><p><strong>header</strong> (<em>str</em><em>,</em><em>optional</em>) – None if missing header, otherwise pandas
header keyword; defaults to ‘infer’</p></li>
<li><p><strong>keep_separate</strong> (<em>bool</em>) – whether to seperate polynomial columns if reading a list of files and using the addpoly option; defaults to True</p></li>
<li><p><strong>unique_cols</strong> (<em>list</em><em>, </em><em>optional</em>) – additional columns to keep seperate across files (e.g. spikes); defaults to []</p></li>
<li><p><strong>fill_na</strong> (<em>str/int/float</em><em>, </em><em>optional</em>) – what value fill NaNs in with if reading in a list of files; defaults to None</p></li>
<li><p><strong>kwargs</strong> – additional inputs to pandas.read_csv</p></li>
<li><p><strong>Returns</strong> – Design_Matrix class</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-nltools.utils">
<span id="nltools-util-utilities"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.util</span></code>: Utilities<a class="headerlink" href="#module-nltools.utils" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-utilities">
<h3>NeuroLearn Utilities<a class="headerlink" href="#neurolearn-utilities" title="Permalink to this headline">¶</a></h3>
<p>handy utilities.</p>
<dl class="py function">
<dt id="nltools.utils.concatenate">
<code class="sig-prename descclassname"><span class="pre">nltools.utils.</span></code><code class="sig-name descname"><span class="pre">concatenate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#concatenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate a list of Brain_Data() or Adjacency() objects</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.utils.get_anatomical">
<code class="sig-prename descclassname"><span class="pre">nltools.utils.</span></code><code class="sig-name descname"><span class="pre">get_anatomical</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#get_anatomical"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.get_anatomical" title="Permalink to this definition">¶</a></dt>
<dd><p>Get nltools default anatomical image.
DEPRECATED. See MNI_Template and resolve_mni_path from nltools.prefs</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.utils.get_resource_path">
<code class="sig-prename descclassname"><span class="pre">nltools.utils.</span></code><code class="sig-name descname"><span class="pre">get_resource_path</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#get_resource_path"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.get_resource_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get path to nltools resource directory.</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.utils.set_algorithm">
<code class="sig-prename descclassname"><span class="pre">nltools.utils.</span></code><code class="sig-name descname"><span class="pre">set_algorithm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#set_algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.set_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the algorithm to use in subsequent prediction analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – The prediction algorithm to use. Either a string or an
(uninitialized) scikit-learn prediction object. If string,
must be one of ‘svm’,’svr’, linear’,’logistic’,’lasso’,
‘lassopcr’,’lassoCV’,’ridge’,’ridgeCV’,’ridgeClassifier’,
‘randomforest’, or ‘randomforestClassifier’</p></li>
<li><p><strong>kwargs</strong> – Additional keyword arguments to pass onto the scikit-learn
clustering object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary of settings for prediction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>predictor_settings</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.utils.set_decomposition_algorithm">
<code class="sig-prename descclassname"><span class="pre">nltools.utils.</span></code><code class="sig-name descname"><span class="pre">set_decomposition_algorithm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/utils.html#set_decomposition_algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.utils.set_decomposition_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the algorithm to use in subsequent decomposition analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> – The decomposition algorithm to use. Either a string or an
(uninitialized) scikit-learn decomposition object.
If string must be one of ‘pca’,’nnmf’, ica’,’fa’,
‘dictionary’, ‘kernelpca’.</p></li>
<li><p><strong>kwargs</strong> – Additional keyword arguments to pass onto the scikit-learn
clustering object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary of settings for prediction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>predictor_settings</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-nltools.plotting">
<span id="nltools-plotting-plotting-tools"></span><h2><a class="reference internal" href="#module-nltools.plotting" title="nltools.plotting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.plotting</span></code></a>: Plotting Tools<a class="headerlink" href="#module-nltools.plotting" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-plotting-tools">
<h3>NeuroLearn Plotting Tools<a class="headerlink" href="#neurolearn-plotting-tools" title="Permalink to this headline">¶</a></h3>
<p>Numerous functions to plot data</p>
<dl class="py function">
<dt id="nltools.plotting.dist_from_hyperplane_plot">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">dist_from_hyperplane_plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stats_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#dist_from_hyperplane_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.dist_from_hyperplane_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SVM Classification Distance from Hyperplane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>stats_output</strong> – a pandas file with prediction output</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Will return a seaborn plot of distance from hyperplane</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_between_label_distance">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_between_label_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fontsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_between_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_between_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a heatmap indicating average between label distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – (pandas dataframe) brain_distance matrix</p></li>
<li><p><strong>labels</strong> – (pandas dataframe) group labels</p></li>
<li><p><strong>ax</strong> – axis to plot (default=None)</p></li>
<li><p><strong>permutation_test</strong> – (boolean)</p></li>
<li><p><strong>n_permute</strong> – (int) number of samples for permuation test</p></li>
<li><p><strong>fontsize</strong> – (int) size of font for plot</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>heatmap
out: pandas dataframe of pairwise distance between conditions
within_dist_out: average pairwise distance matrix
mn_dist_out: (optional if permutation_test=True) average difference in distance between conditions
p_dist_out: (optional if permutation_test=True) p-value for difference in distance between conditions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_brain">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_brain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objIn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr_upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr_lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>More complete brain plotting of a Brain_Data instance
:param obj: (Brain_Data) object to plot
:param how: (str) whether to plot a glass brain ‘glass’, 3 view-multi-slice mni ‘mni’, or both ‘full’
:param thr_upper: (str/float) thresholding of image. Can be string for percentage, or float for data units (see Brain_Data.threshold()
:param thr_lower: (str/float) thresholding of image. Can be string for percentage, or float for data units (see Brain_Data.threshold()
:param save: if a string file name or path is provided plots will be saved into this directory appended with the orientation they belong to
:type save: str
:param kwargs: optionals args to nilearn plot functions (e.g. vmax)</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_interactive_brain">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_interactive_brain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anatomical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_interactive_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_interactive_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>This function leverages nilearn’s new javascript based brain viewer functions to create interactive plotting functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>brain</strong> (<em>nltools.Brain_Data</em>) – a Brain_Data instance of 1d or 2d shape (i.e. 3d or 4d volume)</p></li>
<li><p><strong>threshold</strong> (<em>float/str</em>) – threshold to initialize the visualization, maybe be a percentile string; default 0</p></li>
<li><p><strong>surface</strong> (<em>bool</em>) – whether to create a surface-based plot; default False</p></li>
<li><p><strong>percentile_threshold</strong> (<em>bool</em>) – whether to interpret threshold values as percentiles</p></li>
<li><p><strong>kwargs</strong> – optional arguments to nilearn.view_img or nilearn.view_img_on_surf</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>interactive brain viewer widget</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_mean_label_distance">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_mean_label_distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fontsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_mean_label_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_mean_label_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a violin plot indicating within and between label distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – pandas dataframe of distance</p></li>
<li><p><strong>labels</strong> – labels indicating columns and rows to group</p></li>
<li><p><strong>ax</strong> – matplotlib axis to plot on</p></li>
<li><p><strong>permutation_test</strong> – (bool) indicates whether to run permuatation test or not</p></li>
<li><p><strong>n_permute</strong> – (int) number of permutations to run</p></li>
<li><p><strong>fontsize</strong> – (int) fontsize for plot labels</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>heatmap
stats: (optional if permutation_test=True) permutation results</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_silhouette">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_silhouette</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_silhouette"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_silhouette" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a silhouette plot indicating between relative to within label distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distance</strong> – (pandas dataframe) brain_distance matrix</p></li>
<li><p><strong>labels</strong> – (pandas dataframe) group labels</p></li>
<li><p><strong>ax</strong> – axis to plot (default=None)</p></li>
<li><p><strong>permutation_test</strong> – (boolean)</p></li>
<li><p><strong>n_permute</strong> – (int) number of samples for permuation test</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Optional keyword args:</dt><dd><p>figsize: (list) dimensions of silhouette plot
colors: (list) color triplets for silhouettes. Length must equal number of unique labels</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>heatmap
# out: pandas dataframe of pairwise distance between conditions
# within_dist_out: average pairwise distance matrix
# mn_dist_out: (optional if permutation_test=True) average difference in distance between conditions
# p_dist_out: (optional if permutation_test=True) p-value for difference in distance between conditions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p># f</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_stacked_adjacency">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_stacked_adjacency</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjacency1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_stacked_adjacency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_stacked_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Create stacked adjacency to illustrate similarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix1</strong> – Adjacency instance 1</p></li>
<li><p><strong>matrix2</strong> – Adjacency instance 2</p></li>
<li><p><strong>normalize</strong> – (boolean) Normalize matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matplotlib figure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.plot_t_brain">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">plot_t_brain</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objIn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">how</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#plot_t_brain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.plot_t_brain" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a brain data object and computes a 1 sample t-test across it’s first axis. If a list is provided will compute difference between brain data objects in list (i.e. paired samples t-test).
:param objIn: (list/Brain_Data) if list will compute difference map first
:param how: (list) whether to plot a glass brain ‘glass’, 3 view-multi-slice mni ‘mni’, or both ‘full’
:param thr: (str) what method to use for multiple comparisons correction unc, fdr, or tfce
:param alpha: (float) p-value threshold
:param nperm: (int) number of permutations for tcfe; default 1000
:param cut_coords: (list) x,y,z coords to plot brain slice
:param kwargs: optionals args to nilearn plot functions (e.g. vmax)</p>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.probability_plot">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">probability_plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stats_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#probability_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.probability_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Classification Probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>stats_output</strong> – a pandas file with prediction output</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Will return a seaborn scatterplot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.roc_plot">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">roc_plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fpr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tpr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#roc_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.roc_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 1-Specificity by Sensitivity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fpr</strong> – false positive rate from Roc.calculate</p></li>
<li><p><strong>tpr</strong> – true positive rate from Roc.calculate</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Will return a matplotlib ROC plot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltools.plotting.scatterplot">
<code class="sig-prename descclassname"><span class="pre">nltools.plotting.</span></code><code class="sig-name descname"><span class="pre">scatterplot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stats_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/plotting.html#scatterplot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.plotting.scatterplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Prediction Scatterplot</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>stats_output</strong> – a pandas file with prediction output</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Will return a seaborn scatterplot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-nltools.simulator">
<span id="nltools-simulator-simulator-tools"></span><h2><a class="reference internal" href="#module-nltools.simulator" title="nltools.simulator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nltools.simulator</span></code></a>: Simulator Tools<a class="headerlink" href="#module-nltools.simulator" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neurolearn-simulator-tools">
<h3>NeuroLearn Simulator Tools<a class="headerlink" href="#neurolearn-simulator-tools" title="Permalink to this headline">¶</a></h3>
<p>Tools to simulate multivariate data.</p>
</div>
<dl class="py class">
<dt id="nltools.simulator.Simulator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltools.simulator.</span></code><code class="sig-name descname"><span class="pre">Simulator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">brain_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="nltools.simulator.Simulator.create_cov_data">
<code class="sig-name descname"><span class="pre">create_cov_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.create_cov_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.create_cov_data" title="Permalink to this definition">¶</a></dt>
<dd><p>create continuous simulated data with covariance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cor</strong> – amount of covariance between each voxel and Y variable</p></li>
<li><p><strong>cov</strong> – amount of covariance between voxels</p></li>
<li><p><strong>sigma</strong> – amount of noise to add</p></li>
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if len(radius) &gt; 1</p></li>
<li><p><strong>center</strong> – center(s) of sphere(s) of the form [px, py, pz] or [[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
<li><p><strong>reps</strong> – number of data repetitions</p></li>
<li><p><strong>n_sub</strong> – number of subjects to simulate</p></li>
<li><p><strong>output_dir</strong> – string path of directory to output data.  If None, no data will be written</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.create_data">
<code class="sig-name descname"><span class="pre">create_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">levels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.create_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.create_data" title="Permalink to this definition">¶</a></dt>
<dd><p>create simulated data with integers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>levels</strong> – vector of intensities or class labels</p></li>
<li><p><strong>sigma</strong> – amount of noise to add</p></li>
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if len(radius) &gt; 1</p></li>
<li><p><strong>center</strong> – center(s) of sphere(s) of the form [px, py, pz] or [[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
<li><p><strong>reps</strong> – number of data repetitions useful for trials or subjects</p></li>
<li><p><strong>output_dir</strong> – string path of directory to output data.  If None, no data will be written</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.create_ncov_data">
<code class="sig-name descname"><span class="pre">create_ncov_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.create_ncov_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.create_ncov_data" title="Permalink to this definition">¶</a></dt>
<dd><p>create continuous simulated data with covariance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cor</strong> – amount of covariance between each voxel and Y variable (an int or a vector)</p></li>
<li><p><strong>cov</strong> – amount of covariance between voxels (an int or a matrix)</p></li>
<li><p><strong>sigma</strong> – amount of noise to add</p></li>
<li><p><strong>mask</strong> – region(s) where we will have activations (list if more than one)</p></li>
<li><p><strong>reps</strong> – number of data repetitions</p></li>
<li><p><strong>n_sub</strong> – number of subjects to simulate</p></li>
<li><p><strong>output_dir</strong> – string path of directory to output data.  If None, no data will be written</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the prediction algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.gaussian">
<code class="sig-name descname"><span class="pre">gaussian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_tot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.gaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>create a 3D gaussian signal normalized to a given intensity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> – average value of the gaussian signal (usually set to 0)</p></li>
<li><p><strong>sigma</strong> – standard deviation</p></li>
<li><p><strong>i_tot</strong> – sum total of activation (numerical integral over the gaussian returns this value)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.n_spheres">
<code class="sig-name descname"><span class="pre">n_spheres</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.n_spheres"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.n_spheres" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a set of spheres in the brain mask space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> – vector of radius.  Will create multiple spheres if len(radius) &gt; 1</p></li>
<li><p><strong>centers</strong> – a vector of sphere centers of the form [px, py, pz] or [[px1, py1, pz1], …, [pxn, pyn, pzn]]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.normal_noise">
<code class="sig-name descname"><span class="pre">normal_noise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.normal_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.normal_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>produce a normal noise distribution for all all points in the brain mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu</strong> – average value of the gaussian signal (usually set to 0)</p></li>
<li><p><strong>sigma</strong> – standard deviation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.sphere">
<code class="sig-name descname"><span class="pre">sphere</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>create a sphere of given radius at some point p in the brain mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> – radius of the sphere</p></li>
<li><p><strong>p</strong> – point (in coordinates of the brain mask) of the center of the sphere</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltools.simulator.Simulator.to_nifti">
<code class="sig-name descname"><span class="pre">to_nifti</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nltools/simulator.html#Simulator.to_nifti"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltools.simulator.Simulator.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a numpy matrix to the nifti format and assign to it the brain_mask’s affine matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>m</strong> – the 3D numpy matrix we wish to convert to .nii</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
</ul>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/api.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2020, Cosan Laboratory.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>